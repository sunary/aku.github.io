[
    
        
            {
                "ref": "https://sunary.github.io/public/post/002-dynamic-programming/",
                "title": "Quy hoạch động",
                "section": "post",
                "date" : "2020.04.11",
                "body": "Chắc ai từng làm các bài thuật toán cũng từng nghe đến quy hoạch động (DP), thực ra nó không cao siêu khó hiểu như các bạn nghĩ. Lý do mình viết bài này để để tham chiếu, vì các bài trong tương lai mình nghĩ sẽ dùng phương pháp này nhiều.\nĐịnh nghĩa: Mình tìm kiếm 1 vài chỗ thì thấy DP được định nghĩa khá đầy đủ như sau:\nDynamic Programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions using a memory-based data structure (array, map,etc). Hiểu 1 cách đơn giản đó là chia bài toán thành các bài toán nhỏ đơn giản hơn, nhưng đơn giản hơn như thế nào???\nNếu các bạn đã từng nghe có 1 phương pháp giải toán là quy nạp thì DP cũng tương tự như vậy:\nĐể chứng minh một mệnh đề đúng với mọi n ∈ N bằng phương pháp **quy nạp toán học**, ta thực hiện các bước sau: 1. Kiểm tra mệnh đề đúng với n = 1. 2. Giả sử mệnh đề đúng với n = k ≥ 1 (giả thiết quy nạp). 3. Cần chứng minh mệnh đề đúng với n = k + 1. Thì mình định nghĩa lại DP ở đây một chút: giả thiết các bạn giải quyết được bài toán với n = k, thì sẽ giải quyết được bài toán với n = k + 1.\nCũng chưa đơn giản lắm, cứ đi vào ví dụ xem như thế nào.\nLet the hunt begin: Cho mảng N, tính tổng của N. =)) yeah, làm từ bài dễ đến vừa.\nRất đơn giản thôi:\nsum_N = 0 for i in range(len(N)): sum_N += N[i] Vậy DP ở đâu ra? để ý rằng để giả sử N bạn giải quyết được bài toán với n = k (nhắc lại) thì với n = k + 1, sum_N sẽ được tính lại bằng: sum_N = sum_N + N[k + 1]. Chính việc bạn giải quyết bài toán qua từng phần tử thì gọi là DP rồi.\nTương tự như vậy, với bài fibonacci thì sao?\nf0 = 1 f1 = 1 for _ in range(2, n): f0, f1 = f1, f0 + f1 Tương tự như giải thích phía trên, cứ mỗi bước i trong vòng lặp bạn đã giải quyết được bài toán đến i, thì các bước sau i cũng sẽ được giải quyết tương tự.\nOk, sang 1 ví dụ vừa vừa nào\nTính tổng lớn nhất max_sum của dãy con liên tiếp thuộc dãy N. // Không hiểu sao bài này được khá nhiều cty hỏi lúc pv. Mình gặp 2 cty rồi.\nVí dụ:  input:  N = [4, -1, -2, 1, 5, -3]  ouput:  7  giải thích:  Tổng lớn nhất của dãy con liên tiếp thuộc về dãy: [4, -1, -2, 1, 5] và có tổng là: 7\n Chúng ta đang lấy ví dụ cho DP, thì qua về lý thuyết 1 chút:\n Giải quyết bài toán với vị trí n = 0 Giải quyết bài toán với vị trí n = i Giải quyết bài toán với vị trí n = i + 1  Giải quyết bài toán với vị trí n = 0\nVới n = 0 thì max_sum = N[0] quá dễ.\nGiải quyết bài toán với vị trí n = i\nOk, xem như ta giải quyết dc.\nGiải quyết bài toán với vị trí n = i + 1\nNếu max_sum là tổng lớn nhất đến vị trí i, thì với i + 1 ta làm thế nào? Lấy lại input của ví dụ trên:\nmax_sum = N[0] = 4 i = 0, n = 0 + 1 = 1, tức N[1] = -1. Nhận thấy nếu thêm -1 vào max_sum thì max_sum bị giảm (ko phải max nữa, nên ko cộng). max_sum vẫn là 4. i = 1, n = 1 + 1 = 2, tức N[2] = -2. Nhận thấy nếu thêm -1 và -2 vào max_sum thì max_sum bị giảm (ko phải max nữa, nên ko cộng). max_sum vẫn là 4. i = 2, n = 2 + 1 = 3, tức N[3] = 1. Nhận thấy nếu thêm -1, -2 và 1 vào max_sum thì max_sum bị giảm (ko phải max nữa, nên ko cộng). max_sum vẫn là 4. i = 3, n = 3 + 1 = 4, tức N[4] = 5. Nhận thấy nếu thêm -1, -2, 1 và 5 vào max_sum thì max_sum tăng thành 7 (giử lại). i = 4, n = 4 + 1 = 5, tức N[5] = -3. Nhận thấy nếu thêm -3 vào max_sum thì max_sum bị giảm (ko phải max nữa, nên ko cộng). max_sum vẫn là 7. i chạy hết rồi, nên max_sum = 7 là kết quả bài toán. Và cuối cùng là code:\nmax_sum, last_max_sum = N[0], N[0] id_last = 0 for i in range(1, len(N)): if last_max_sum \u0026lt;= 0: last_max_sum = N[i] id_last = i else: last_max_sum += N[i] if last_max_sum \u0026gt;= max_sum: max_sum = last_max_sum Từ lập luận trên sao ra được đoạn code ngắn, khó hiểu vậy? Giải thích từ lập luận thì mình nói trên rồi, giờ thử giải thích từ code:\nlast_max_sum là kết quả max_sum nhưng có chứa phần tử cuối cùng, vì sao cần biến này là nếu không có nó thì tổng của bạn không liên tục được khiến bài toán không thể giải được. Ví dụ: N = [-2, 4, -1] thì max_sum = sum([4]), còn last_max_sum = sum([4, -1]) vì nếu N = [-2, 4, -1, 3] mà bạn không giử lại -1, thì bạn sẽ không tính được max_sum = last_max_sum = sum([4, -1, 3]) Phần giới thiệu đến đây là hết, nếu các bạn chưa rõ thì xin để lại phản hồi qua email.\nVà thay cho lời kết thì mình cũng đưa ra 1 bài tương tự, dùng DP và cũng từng là 1 câu hỏi phỏng vấn của mình:\nCho dãy số N là giá trị cổ phiếu của 1 công ty theo thứ tự thời gian. Bạn hãy tính lợi nhuận cao nhất nếu mua cổ phiếu cty tại thời điểm i và bán ở thời điểm j (tức i \u0026lt; j) Ví dụ:  input:  N = [7, 5, 8, 20, 3, 17]  ouput:  15  giải thích:  Bạn mua vào thời điểm giá cổ phiếu là 5, bán vào lúc 20. Lợi nhuận là 20 - 5 = 15\n References:  mathematical-induction top-50-dynamic-programming-practice-problems geeksforgeeks  "
            }
        
    ,
        
            {
                "ref": "https://sunary.github.io/public/post/001-count-2sum/",
                "title": "Đếm các cặp số hoán vị khác nhau bằng tổng cho trước",
                "section": "post",
                "date" : "2020.04.10",
                "body": "Đề bài: Bài này mình được 1 công ty nào đó hỏi lúc phỏng vấn, dạo gần đây có 1 người bạn gửi cho bài 4sum nên nhớ lại và chọn làm bài đầu tiên cho blog luôn.\nCho trước dãy số N, và số k. Đếm tất cả các cặp số hoán vị duy nhất (a, b) sao cho: a + b = k với a, b thuộc N. Ví dụ:  input:  N = [1, 2, 3, 3, 4] k = 5  output:  2  giải thích:  Vì chỉ có 2 cặp số thỏa mãn: (1, 4) và (2, 3) lưu ý: (1, 4) cũng là cặp số (4, 1) nên chỉ đếm 1 lần, tương tự với (3, 2) và (2, 3).\n// Đề bài là mình nhớ lại, nên ko bắt bẻ nếu không chính xác hoặc khó hiểu.\nLet the hunt begin: Nói luôn là bài này mình có hỏi ứng viên khi phỏng vấn ở công ty mình, thì họ phạm 2 lỗi sau:\n Không giải quyết được trường hợp các cặp số hoán vị duy nhất. Tối ưu.  1. Không giải quyết được trường hợp các cặp số hoán vị duy nhất. Lấy luôn ví dụ trên, thì bạn đó giải ra đếm các kết quả của (1, 4), (2, 3), (2, 3), (3, 2), (3, 2), (4, 1)\nCó 2 vấn đề khiến hoán vị bị lặp lại:\n (1, 4) và (4, 1): Bạn đếm 1 hoán vị 2 lần: bạn để ý a + b = k, bạn đếm (a, b) rồi (b, a), không sai. Nhưng làm sao chỉ đếm 1 lần thôi, tức chỉ đếm cho a thôi, không đếm cho b. Rất đơn giản: a + b = k thì 1 trong 2 số a và b phải nhỏ hơn k/2 (có trường hợp a = b = k/2 mình sẽ nói sau), nên code counter của mình sẽ là:  if a \u0026lt; k/2 and a + b == k: counter += 1  (2, 3) và (2, 3): Với số 3 xuất hiện 2 lần thì bạn đếm 2 lần. Cách đơn giản là tạo 1 biến để track những cặp số đã được count trước đó:  marked = {} if not marked.get((a, b)) and a + b == k: counter += 1 marked[(a, b)] = True Nhưng có 1 cách đơn giản hơn là: Tại sao bạn không loại bỏ những số trùng của mảng N cho trước:\ndistinctN = set(N) Bạn nên tự tạo hàm đưa vào distinctN cho riêng mình\ncount = 0 countHaft = 0 distinctN = set() for x in N: if x == k/2: countHaft += 1 else: distinctN.add(x) if countHaft \u0026gt;= 2: count += 1 Lý do mình tự tính distanceN là vì loại bỏ những số a = b = k/2 như đã nói ở trên bằng cách đếm riêng, và xóa nó ra khỏi distinctN.\n2. Tối ưu: Dễ thấy bài toán có thể giải bằng 2 vòng for duyệt qua distinctN:\nfor a in distinctN: for b in distinctN: if a \u0026lt; k/2 and a + b == k: count += 1 Nhưng không biết bạn vừa bỏ qua gì ko? distinctN là set đã được index unique, tức là bạn có thể tìm 1 phần tử bất kì với O(1), và code trên từ O(n^2) thành O(n):\nfor a in distinctN: if a \u0026lt; k/2 and k - a in distinctN: count += 1 Ok, vậy chương trình hoàn chỉnh sẽ là:\ncount = 0 countHaft = 0 distinctN = set() for x in N: if x == k/2: countHaft += 1 else: distinctN.add(x) if countHaft \u0026gt;= 2: count += 1 for a in distinctN: if a \u0026lt; k/2 and k - a in distinctN: count += 1 Thấy vẫn không ưng ý lắm, muốn tối ưu thêm 1 chút nữa: Chuyện là bạn phải duyệt qua tất cả các giá trị trong distinctN nhưng chỉ làm việc với 1 nửa của chúng bằng cách kiểm tra x \u0026lt; k/2. Vậy thì ngay từ đầu mình kiểm tra giùm nó luôn, khỏi phải duyệt một lần nữa:\ncount = 0 countHaft = 0 distinctLowerN = set() distinctHigherN = set() for x in N: if x == k/2: countHaft += 1 elif x \u0026lt; k/2: distinctLowerN.add(x) elif x \u0026gt; k/2: distinctHigherN.add(x) if countHaft \u0026gt;= 2: count += 1 for a in distinctLowerN: if k - a in distinctHigherN: count += 1 Giải quyết bài 4sum đã đề cập ở trên: Bài trên tìm tổng 2 số với O(n) thì bài này làm tương tự với độ phức tạp là O(n^3) (Không phải O(n^2) nghe, bình thường là duyệt qua 4 vòng for, tối ưu được 1 vòng bằng cách tương tự trên thôi). Nhưng không phải dùng set mà là dùng map, đơn giản vì set không lưu được số lượng trùng của các phần tử, và không được loại bỏ các phần tử bằng k/2 hay k/4\ndistinctN = {} for x in N: if x in distinctN: distinctN[x] += 1 else: distinctN[x] = 1 Và tiến hành duyệt 3 vòng for qua N, và check giá trị k - a - b - c có thuộc trong distinctN hay không, nhân đây thì có 1 chút tối ưu: nếu N có nhiều hơn 4 phần tử thì sao? nó sẽ bị dư khi tính toán nên tốt nhất mình nên tái tạo lại N:\nnewN = [] sortedKey = sorted(distinctN.keys()) for x in sortedKey: newN += [x] * min(distinctN.get(x), 4) Vậy chương trình hoàn chỉnh sẽ là:\ncount = 0 distinctN = {} for x in N: if x in distinctN: distinctN[x] += 1 else: distinctN[x] = 1 newN = [] sortedKey = sorted(distinctN.keys()) for x in sortedKey: newN += [x] * min(distinctN.get(x), 4) marked = {} for i in range(len(newN)): for j in range(i + 1, len(newN)): for l in range(j + 1, len(newN)): remain = k - newN[i] - newN[j] - newN[l] if remain \u0026lt; newN[i]: key = (remain, newN[i], newN[j], newN[l]) elif remain \u0026lt; newN[j]: key = (newN[i], remain, newN[j], newN[l]) elif remain \u0026lt; newN[l]: key = (newN[i], newN[j], remain, newN[l]) else: key = (newN[i], newN[j], newN[l], remain) if not marked.get(key) and remain in distinctN: num = distinctN.get(remain) if remain == newN[i]: num -= 1 if remain == newN[j]: num -= 1 if remain == newN[l]: num -= 1 if num \u0026gt; 0: count += 1 marked[key] = True Giải thích 1 chút:\n newN[i], newN[j], newN[l] đã được sort, nên khi chèn remain vào để làm 1 unique quadruplets thì phải đảm bảo chèn remain vào vị trí hợp lí sao cho các giá trị trong quadruplets là tăng dần. Sẽ ra sao nếu chỉ có 1 số a nằm trong N mà new[i] == a và remain == a, đó là lý do biến num ra đời.  Submit Thử submit thì pass, nhưng kết quả không được tốt lắm, chắc sẽ có thêm mấy cái cần tối ưu.\nSuccess Details Runtime: 2064 ms, faster than 5.88% of Python online submissions for 4Sum. Memory Usage: 13 MB, less than 13.64% of Python online submissions for 4Sum. // Sẽ cập nhật nếu thêm được cái gì\n References:  4sum  "
            }
        
    
]